#pragma warning disable IDE0240
#nullable enable
#pragma warning restore IDE0240
using System;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace EasyCSharp.GeneratorTools;

public abstract class AttributeBaseGenerator<TAttribute, TAttributeDataType, TSyntaxNode, TSymbol> : IIncrementalGenerator
    // The User-Defined Attribute Type to process
    where TAttribute : Attribute
    // The Attribute Type to be used for AttributeData to custom struct
    where TAttributeDataType : struct
    // The SyntaxNode type to process
    where TSyntaxNode : MemberDeclarationSyntax
    // The Symbol type to process
    where TSymbol : ISymbol
{
    static readonly string FullAttributeName = typeof(TAttribute).FullName;
    
    protected virtual void Initialize(IncrementalGeneratorPostInitializationContext context) { }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(Initialize);
        var output = context.SyntaxProvider.CreateSyntaxProvider(
            static (syntaxNode, cancelationToken) => syntaxNode is TSyntaxNode,
            Transform
        );
        output = output.Where(static x => x.FileName is not null);

        context.RegisterSourceOutput(output, (sourceProductionContext, value) =>
        {
            sourceProductionContext.AddSource(value.FileName!, value.Content!);
        });
    }
    protected abstract TAttributeDataType TransformAttribute(AttributeData attributeData, Compilation compilation);
    protected abstract string? OnPointVisit(GeneratorSyntaxContext genContext, TSyntaxNode syntaxNode, TSymbol symbol, TAttributeDataType[] attributeData);
    (string? FileName, string? Content) Transform(GeneratorSyntaxContext genContext, CancellationToken cancelationToken)
    {
        DateTime TransformBegin = DateTime.Now;
        var syntaxNode = (TSyntaxNode)genContext.Node;
        // Filter out everything which has no attribute
        if (syntaxNode.AttributeLists.Count is 0) return (null, null);

        // Get Symbol
        var uncastedSymbol = genContext.SemanticModel.GetDeclaredSymbol(syntaxNode);
        if (uncastedSymbol is not TSymbol symbol) return (null, null);

        // Get Attributes
        var attributes = (
            from x in symbol.GetAttributes()
            where x.AttributeClass?.ToDisplayString() == FullAttributeName
            select TransformAttribute(x, genContext.SemanticModel.Compilation)
        ).ToArray();
        
        if (attributes.Length is 0) return (null, null);
        string? output;
        DateTime BeforeProcess = DateTime.Now;
        // All conditions satistfy except for actual running generator
        try
        {
            output = OnPointVisit(genContext, syntaxNode, symbol, attributes);
            if (output is null) return (null, null);
        } catch (Exception e)
        {
            // Log the exception
            output = $"""
            /*
                Exception Occured: {e.GetType().FullName}{e.Message}
                Messsage: {e.Message}
                Stack Trace:
                    {e.StackTrace.IndentWOF(1)}
            */
            """;
        }
        DateTime ProcessCompleted = DateTime.Now;
        // All conditions satisfy
        var containingClass = symbol.ContainingType;
        var genericParams = containingClass.TypeParameters;
        var classHeader =
            genericParams.Length is 0 ?
                containingClass.Name :
                $"{containingClass.Name}<{string.Join(", ", from x in genericParams select x.Name)}>";
        TimeSpan EntireProcess = ProcessCompleted - TransformBegin;
        TimeSpan SubProcess = ProcessCompleted - BeforeProcess;
        return ($"{symbol}.g.cs", $$"""
            #nullable enable
            // Autogenerated for {{symbol}}
            // This Generator took {{EntireProcess.TotalMilliseconds}}ms ({{EntireProcess.Ticks}} ticks) in total
            // SubProcess took {{SubProcess.TotalMilliseconds}}ms ({{SubProcess.Ticks}} ticks)

            namespace {{containingClass.ContainingNamespace}}
            {
                partial class {{classHeader}}
                {
                    {{output.IndentWOF(2)}}
                }
            }
            """);
    }
}